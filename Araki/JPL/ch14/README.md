# 演習問題一覧

## ex14_01/


`P.297`

mainを実行しているスレッドの名前を表示するプログラムを作成しなさい。

## ex14_02/


`P.300`

最初のバージョンのPrintServerを修正して、本文で述べたように、スレッドの識別によりコンストラクタで生成されたスレッドだけがrunを実行できるようにしなさい。


本文の抜粋
----------


`P.299`

１つの解決方法は、`Thread.currentThread` を使用して、runメソッドを呼び出しているスレッドがどれかを調べて本来のワーカースレッドと比較すること

## ex14_03/


`P.308`

現在の値を保持し、その値に加算して新たな値を表示するメソッドを持つオブジェクトのクラスを作成しなさい。
そのオブジェクトを生成し、複数のスレッドを生成して、各スレッドからその加算メソッドを繰り返し呼び出すプログラムを作成しなさい。
加算の結果が失われないようにそのクラスを作成しなさい。



## ex14_04/


`P.308`

ex14_03 を修正して、staticデータとstaticメソッドを使用するようにしなさい。



## ex14_05/


`P.308`

ex14.04 のコードを修正して、staticの同期されたメソッドを使用しないでスレッドが安全に値を減算できるようにしなさい。



## ex14_06/


`P.311`

15秒間隔でメッセージを表示する別のスレッドを待ち、実行開始からの経過時間を表示するプログラムを作成しなさい。
メッセージ表示スレッドは、時間表示スレッドから1秒経過するごとに通知されるようにしなさい。
時間表示スレッドを修正することなく、7秒間隔で異なるメッセージを表示する別のスレッドを追加しなさい。



## ex14_07/


`P.315`

Babbleを複数回実行して、結果を調べなさい。常に同じ結果ですか？
可能なら、異なるシステムで実行して比較しなさい。


解答
====

yield を実行すると、順序が変わる

## ex14_08/


`P.317`

Friendlyプログラムを試しなさい。
使用しているシステムでどの程度の頻度で実際にデッドロックが発生しますか？
yield呼び出しを追加したら、デッドロックの頻度を変更できますか？
もし可能なら、この練習問題を1種類以上のシステムで試しなさい。
同期を削除することなくデッドロックの可能性を取り除いてみなさい。

結論
====

実行環境：
4CPU (HTで8 core に見える)

デッドロックの頻度を変えることはできなかった。（ほぼデッドロックとなった）
理由：
* yieldを指定したとしても相手のThreadも同様にyieldするため、デッドロックを回避する動作にはならない。


## ex14_09/


`P.330`

スレッドグループを引数に取り、そのグループ内のスレッドとスレッドグループの階層を定期的に表示するスレッドを開始するメソッドを書きなさい。
そのメソッドを、様々なグループ内でいくつかの短命なスレッドを生成するプログラムでテストしなさい。

